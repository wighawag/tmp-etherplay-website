{
  "version": 3,
  "sources": ["C:\\dev\\etherplay\\new_website\\src\\lib\\graphql\\queryStore.ts"],
  "sourcesContent": ["import type {Readable} from 'svelte/store';\nimport {writable} from 'svelte/store';\nimport {query, InternalQueryState} from './query';\n\nexport type QueryState<T> = {\n  state: 'Idle' | 'Fetching' | 'Ready';\n  error: unknown;\n  polling: boolean;\n  stale: boolean;\n  data?: T;\n};\n\nexport type QueryStore<T> = Readable<QueryState<T>> & {\n  fetch: () => QueryStore<T> | void;\n  cancel: (options?: {clear?: boolean}) => void;\n  acknowledgeError: () => void;\n};\n\nexport function queryStore<T>(\n  queryString: string,\n  options: {\n    variables?: Record<string, unknown>;\n    once?: boolean;\n    transform?: string | ((v: unknown) => T);\n  } = {}\n): QueryStore<T> {\n  let stopCurrentQuery: () => void;\n\n  const $data: QueryState<T> = {\n    state: 'Idle',\n    error: undefined,\n    polling: false,\n    stale: false,\n  };\n  const {subscribe, set} = writable($data);\n\n  function _set(data: Partial<QueryState<T>>) {\n    Object.assign($data, data);\n    set($data);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function onResult(result: InternalQueryState<any>) {\n    if (result.fetching) {\n      _set({state: 'Fetching'});\n    }\n    _set({stale: result.stale});\n    if (result.error) {\n      _set({error: result.error});\n    } else if (result.data) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let data: any = result.data;\n      if (typeof options?.transform === 'string') {\n        if (data[options.transform]) {\n          data = data[options.transform];\n        } else {\n          _set({\n            error: {\n              code: 11,\n              message: `${options.transform} does not exist in result.data: ${data}`,\n            },\n          });\n        }\n      } else if (options.transform) {\n        data = options.transform(data);\n      }\n      _set({state: 'Ready', polling: !options.once});\n      _set({data});\n    }\n  }\n\n  const store = {\n    subscribe,\n    fetch,\n    cancel,\n    acknowledgeError,\n  };\n\n  function fetch() {\n    if ($data.state !== 'Idle') {\n      return;\n    }\n\n    stopCurrentQuery = query({\n      query: queryString,\n      variables: options.variables,\n      context: {\n        pollInterval: options.once ? undefined : 2000,\n        requestPolicy: 'cache-and-network', // required as cache-first will not try to get new data\n      },\n    }).subscribe(onResult);\n\n    return store;\n  }\n\n  function cancel(options: {clear?: boolean} = {}) {\n    if (stopCurrentQuery) {\n      stopCurrentQuery();\n      _set({state: 'Idle', polling: false, stale: false, error: undefined});\n      if (options.clear) {\n        _set({data: undefined});\n      }\n    }\n  }\n\n  function acknowledgeError() {\n    _set({error: undefined});\n  }\n\n  return store;\n}\n"],
  "mappings": "AACA;AACA;AAgBO,2BACL,aACA,UAII;AAEJ,MAAI;AAEJ,QAAM,QAAuB;AAAA,IAC3B,OAAO;AAAA,IACP,OAAO;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA;AAET,QAAM,CAAC,WAAW,OAAO,SAAS;AAElC,gBAAc;AACZ,WAAO,OAAO,OAAO;AACrB,QAAI;AAAA;AAIN,oBAAkB;AAChB,QAAI,OAAO;AACT,WAAK,CAAC,OAAO;AAAA;AAEf,SAAK,CAAC,OAAO,OAAO;AACpB,QAAI,OAAO;AACT,WAAK,CAAC,OAAO,OAAO;AAAA,eACX,OAAO;AAEhB,UAAI,OAAY,OAAO;AACvB,UAAI,OAAO,SAAS,cAAc;AAChC,YAAI,KAAK,QAAQ;AACf,iBAAO,KAAK,QAAQ;AAAA;AAEpB,eAAK;AAAA,YACH,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS,GAAG,QAAQ,4CAA4C;AAAA;AAAA;AAAA;AAAA,iBAI7D,QAAQ;AACjB,eAAO,QAAQ,UAAU;AAAA;AAE3B,WAAK,CAAC,OAAO,SAAS,SAAS,CAAC,QAAQ;AACxC,WAAK,CAAC;AAAA;AAAA;AAIV,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAGF;AACE,QAAI,MAAM,UAAU;AAClB;AAAA;AAGF,uBAAmB,MAAM;AAAA,MACvB,OAAO;AAAA,MACP,WAAW,QAAQ;AAAA,MACnB,SAAS;AAAA,QACP,cAAc,QAAQ,OAAO,SAAY;AAAA,QACzC,eAAe;AAAA;AAAA,OAEhB,UAAU;AAEb,WAAO;AAAA;AAGT,kBAAgB,WAA6B;AAC3C,QAAI;AACF;AACA,WAAK,CAAC,OAAO,QAAQ,SAAS,OAAO,OAAO,OAAO,OAAO;AAC1D,UAAI,SAAQ;AACV,aAAK,CAAC,MAAM;AAAA;AAAA;AAAA;AAKlB;AACE,SAAK,CAAC,OAAO;AAAA;AAGf,SAAO;AAAA;",
  "names": []
}
